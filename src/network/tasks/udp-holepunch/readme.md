# UDP Hole Punching Chat System

This project demonstrates a peer-to-peer chat application in Go that uses NAT traversal (UDP hole punching) with a relay fallback. It consists of three main components:

* **addressutils**: Utility package for obtaining private and public IP addresses.
* **relay**: A UDP relay server that helps peers discover each other's addresses and optionally forwards messages when direct connection fails.
* **peer**: A CLI-based peer application that can register with the relay, punch through NATs, exchange messages directly, and fall back to the relay when necessary.

---

## ğŸ“ Project Structure

```
udpholepunchtest/              # Module root (go.mod)
â”œâ”€â”€ addressutils/              # Utility package
â”‚   â””â”€â”€ addressutils.go        # GetPrivateIP(), GetPublicIP()
â”œâ”€â”€ peer/
â”‚   â””â”€â”€ peer.go                # Peer CLI application
â”œâ”€â”€ relay/
â”‚   â””â”€â”€ relay.go               # Relay server application
â”œâ”€â”€ go.mod
â””â”€â”€ go.sum
```

---

## ğŸ”§ addressutils Package

* **Purpose**: Provides functions to determine the host's private LAN IP and the public IP\:port via a STUN server.

* **STUN Server Used**: `stun.l.google.com:19302` (UDP4).

---

## ğŸ—ƒ Data Structures

Both `peer` and `relay` use a shared `PeerInfo` struct:

```go
type PeerInfo struct {
    privateAddr  string  // LAN address (IP:port)
    publicAddr   string  // WAN address (IP:port) reported by STUN
    peerID       string  // Unique identifier generated by relay
    connectedVia string  // Relay's IP:Port (public or private) through which peer connected during registration
}
```

* Stored in a global map on the relay:

```go
var peers = make(map[string]PeerInfo)
```

* **Key**: `peerID` string
* **Value**: `PeerInfo` with both private and public addresses and the relay connection path (`connectedVia`)

This `connectedVia` field allows the relay to remember whether the peer initially connected using the relay's **public IP** (WAN) or **private IP** (LAN), which is used in the case of fallback to relay when hole punching fails

## ğŸš€ Relay Server (`relay.go`) (`relay.go`)

1. **Startup**:

   * Listens on `0.0.0.0:8000` for UDP.
   * Obtains its own private and public addresses via `addressutils`.
2. **Register Command** (`register <privateAddr> <publicAddr>`):

   * Stores a new `peerID` and associated addresses in `peers` map.
3. **Connect Command** (`connectpeer <peerID>`):

   * Looks up the requesting peer and target peer in `peers` map.
   * Sends each side the other's `peerinfo` (both public and private addresses).
4. **Relay Forwarding** (`relaymsg <peerID> <message>`):

   * Forwards chat messages when direct UDP fails.

---

## ğŸ—£ï¸ Peer Application (`peer.go`)

1. **Startup**:

   * Binds to `0.0.0.0:<myPort>`.
   * Discovers `privateAddr` and `publicAddr` via `addressutils`.
   * Prints listening addresses.
2. **Commands**:

   * `register <relayPubIP:port> <relayPrivIP:port>`

     * Sends `register <privateAddr> <publicAddr>` to relay (both public and private endpoints).
   * `connectpeer <peerID>`

     * Requests peer info for `<peerID>` from relay.
   * `send <message>`

     * Sends `msg` either directly (if hole punching succeeded) or as `relaymsg <peerID> <msg>` to the relay.
3. **Listening Loop**:

   * Handles incoming UDP packets:

     * `peerinfo`: Triggers NAT punching to both public and private addresses and starts `checkHolePunching`.
     * `punch`: Marks `myHolePunched = true` and replies with `ack`.
     * `ack`: Marks `peerHolePunched = true` and notes whether it was via public or private address.
     * Default: Prints chat messages.
4. **Hole Punching**:

   * Sends 3 `punch` packets to both public and private addresses.
   * `checkHolePunching()` waits up to 10s for **both** `myHolePunched` and `peerHolePunched` to become `true`:

     * Success: Direct chat enabled.
     * Timeout: Relay fallback mode activated.

---

## â±ï¸ NAT Hole Punching Flow

1. **Peer A** and **Peer B** both run `punch(addr, type)` on the other's public and private endpoints.
2. Routers create NAT mappings when they see outbound `punch` packets.
3. When a peer receives `punch`, it sets `myHolePunched = true` and sends back `ack`.
4. When receiving `ack`, a peer sets `peerHolePunched = true`.
5. `checkHolePunching()` considers the connection successful only if **both** sides have `myHolePunched && peerHolePunched`.

---

## ğŸ”„ Relay Fallback

If hole punching fails after 10 seconds:

* `checkHolePunching` prints fallback messages.
* When the user types `send <message>`, the peer application automatically falls back to using the relay.
* Internally, the peer formats the message as:

  ```
  relaymsg <peerID> <message>
  ```
* This UDP packet is sent to the relay (on both its public and private IPs).
* The relay looks up `<peerID>` in its `peers` map and forwards the payload to the intended peer.
* The relay forwards the message through the **same address the peer originally used to connect during registration (`connectedVia`)**, ensuring reliable communication whether the peer was connected via LAN or WAN.

â†’ **The user does NOT type `relaymsg` manually â€” this is handled automatically within the peer's code when direct peer-to-peer connection fails.**

## ğŸ’» How to Run

```bash
# From module root
# Start the relay:
go run relay/relay.go

# In two different terminals, start peers:
go run peer/peer.go 4001
go run peer/peer.go 4002

# In each peer terminal:
> register <relayPubIP:8000> <relayPrivIP:8000>
> connectpeer <otherPeerID>
> send Hello over NAT!
```

---

